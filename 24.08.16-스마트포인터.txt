-- 포인터 관리 --

포인터 관리의 핵심은 잘 할당하고 잘 해제하는 것이다.

그것을 잘 해주기 위해서 레퍼런스카운트라는 개념을 도입한다.

-- 레퍼런스 카운트 -- 

어떤 객체를 생성하거나 소멸할 때 그 객체의 최상위클래스에 레퍼런스 카운트라는 int 값 하나를 넣어서 관리한다.

그 객체를 참조하게 된다면 레퍼런스 카운트 값을 +1 : addref()
만약 그 객체를 더 이상 사용하지 않고 해제하고 싶다면 -1 이런식으로 관리해주는 것이다. : release()

레퍼런스 카운트가 0이되면 delete this; 를 호출하여 진짜 그 객체를 해제한다.

이 레퍼런스 카운트 개념을 사용하게 되면 다른곳에서 해제해야할 때 delete가 아닌 release를 호출하여 레퍼런스 카운트만 줄이고
해제는 하지않아 아직 그 객체를 참조하는 곳이 남아있어도 문제없이 사용할 수 있다.


-- 스마트 포인터 --

스마트 포인터에서 가장 중요한 것은 레퍼런스카운터를 우리가 수동으로 직접 조작하는 것이 아니라 레퍼 클래스로 자동 혹은 간접적으로 조작하게 만드는 것이다.

복사가 일어날 때 상대방의 레퍼런스 카운트를 1증가시켜서 이후 추가 코드 없이 이미 다음 줄 코드로 넘어오면 1 증가가 된 상태가 되도록 한다.

이 점이 멀티쓰레드에서는 타이밍적으로 문제가 발생하는 것을 막을 수 있다.


C++ 표준에 shared_ptr이라는 것이 있다. 이것으로 관리하면 위에서 말한 것들을 포함하고있기 때문에 편리하게 관리해 줄 수 있다.
단 내부적으로 어떤 방식으로 구현되어있는지는 한 번 더 자세히 알아보고 사용하는 것이 좋다.


-- 스마트포인터로 객체 this를 사용해야 할 때 --

스마트 포인터는 레퍼 클래스로 (레퍼 클래스(wrapper class) : 기본 자료형을 클래스로 감싸(Wrap) 사용하는 것을 말한다.)

스마트 포인터를 사용할 때는 우리가 직접 레퍼런스 카운터를 관리해줄 때처럼 
최상위 부모클래스인 레퍼런스 카운터가
하나로 묶여서 생성되어지는것이 아니라
다른 공간에 따로 만들어지기 때문에 그곳에서 레퍼런스 카운터가 작동한다.

그래서 this로 내 클래스 객체의 주소를 직접 넘겨주면서 새로운 shared_ptr을 만들게 되면
또 다른 공간에 레퍼런스카운트를 관리하는 블록을 만들어서 레퍼런스카운트를 따로 관리하게 된다.

이렇게 되면 한 곳에서 삭제가 일어나게 되면 원래는 
본인 생성 + 새로운 곳에서 this참조 = 2
이렇게 해서 레퍼런스 카운터가 2여야 하지만

처음에 생성한 셰어드 포인터의 레퍼런스 카운트 : 1 , 들고있는 포인터 this

나중에 생성한 레퍼런스 카운트 : 1 , 들고있는 포인터 this


이렇게 되어있어서 어느 한 곳에서 삭제가 발생할 경우 해당 포인터가 삭제되어서
다른 곳에서 접근시에 터져버리는 문제가 발생할 수 있다.


그래서 절대로 shared_ptr<DwClass> cDw =  shared_ptr<DwClass>(this);

이러한 방식으로는 사용하면 안된다.


멤버변수로 본인의 weak_ptr을 따로 가지고 그것을 넘기던지 아니면

내 클래스에 
class DwClass : public enable_shared_from_this<DwClass>
{
...
};


이런식으로 public enable_shared_from_this<DwClass>를 추가하여 만들어서



class DwClass : public enable_shared_from_this<DwClass>
{
public:
	void Test()
	{
		Move(shared_form_this());
	}
	void Move(shared_ptr<DwClass> _P)
	{
		
	}
...
};

이런식으로 shared_form_this()를 사용하여 넘겨주는 것이 안전하다.


핵심은 어떻게든 본인의 포인터를 직접 넘겨서 만들지 않고 
자신의 셰어드 포인터를 넘기도록 해야한다.

스마트포인터는 객체와 레퍼런스카운터를 다른 블록에서 만들어 관리하기 때문이다.
객체 자체를 참조했다 해제했다 해도 스마트 포인터에 감싸져있지 않으면 레퍼런스 카운터가 없는것이다.



